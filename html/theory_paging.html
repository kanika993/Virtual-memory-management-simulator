<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="f_design(pageTheory).css">
    <title>Paging in Virtual Memory Management</title>
</head>

<body>
    <nav class="navbar">
        <ul>
            <li><a href="#definition">Definition</a></li>
            <li><a href="#advantages">Advantages</a></li>
            <li><a href="#disadvantages">Disadvantages</a></li>
            <li><a href="#algorithms">Common Page Replacement Algorithms</a></li>
        </ul>
    </nav>

    <header class="hero">
        <h1>Understanding Paging in Virtual Memory</h1>
        <p>A comprehensive overview of paging as a memory management technique.</p>
    </header>

    <section class="theory-section" id="definition">
        <h2>What is Paging?</h2>
        <p><b>Paging</b> is a memory management scheme that eliminates the need for contiguous allocation of physical memory and thus eliminates the problems of fitting varying sized memory chunks onto the backing store. It divides the virtual memory into fixed-size blocks called pages, which are mapped to physical memory frames.</p>

        <div class="container">
            <h1>Key Concepts of Paging</h1>
            <div class="concept" onclick="toggleExplanation('virtualMemory')">
                <h2>Page Table</h2>
                <div id="virtualMemory" class="explanation">
                    <p>The page table is a data structure used by the operating system to keep track of the mapping between virtual addresses and physical addresses. Each process has its own page table, which allows the OS to manage memory efficiently.</p>
                </div>
            </div>
    
            <div class="concept" onclick="toggleExplanation('pagingMechanism')">
                <h2>Paging Mechanism</h2>
                <div id="pagingMechanism" class="explanation">
                    <p>When a program accesses a page that is not currently in physical memory, a page fault occurs. The operating system then retrieves the required page from disk storage and loads it into RAM, updating the page table accordingly.</p>
                </div>
            </div>
    
            <div class="concept" onclick="toggleExplanation('swapSpace')">
                <h2>Swap Space</h2>
                <div id="swapSpace" class="explanation">
                    <p>Swap space is a reserved area on the hard drive used to store pages that are not currently in use. When physical memory is full, the OS can move inactive pages to swap space, freeing up RAM for active processes.</p>
                </div>
            </div>
        </div>
    </section>

    <section class="theory-section" id="advantages">
        <h2>Advantages of Paging</h2>
        <ul>
            <li><b>Efficient Memory Utilization:</b> Paging allows for non-contiguous memory allocation, which helps in utilizing memory more efficiently.</li>
            <li><b>Isolation:</b> Each process operates in its own virtual address space, enhancing security and stability.</li>
            <li><b>Reduced Fragmentation:</b> Paging helps to minimize external fragmentation, as memory is allocated in fixed-size blocks.</li>
            <li><b>Flexibility:</b> The operating system can easily manage memory allocation and deallocation, allowing for dynamic memory management.</li>
        </ul>
    </section>

    <section class="theory-section" id="disadvantages">
        <h2>Disadvantages of Paging</h2>
        <ul>
            <li><b>Performance Overhead:</b> Page faults can introduce latency, as accessing data from disk is slower than accessing it from RAM.</li>
            <li><b>Complexity:</b> The management of page tables and the paging mechanism adds complexity to the operating system.</li>
            <li><b>Internal Fragmentation:</b> Fixed-size pages can lead to wasted space within pages if the data does not fill the entire page.</li>
            <li><b>Dependency on Disk Speed:</b> The performance of paging is heavily reliant on the speed of the disk, which can be a bottleneck.</li>
        </ul>
    </section>

    <section class="theory-section" id="algorithms">
        <h2>Common Page Replacement Algorithms</h2>
        <div class="theory-content">
            <div class="theory-item">
                <h3>Least Recently Used (LRU)</h3>
                <p>Evicts the page that has not been used for the longest time. This algorithm is effective in scenarios where recent usage is a good predictor of future use.</p>
            </div>
            <div class="theory-item">
                <h3>First-In-First-Out (FIFO)</h3>
                <p>Evicts the oldest page in memory, regardless of how often it has been used. While simple to implement, it may not always yield optimal performance.</p>
            </div>
            <div class="theory-item">
                <h3>Optimal Page Replacement</h3>
                <p>Evicts the page that will not be used for the longest time in the future. This algorithm serves as a theoretical benchmark for evaluating other algorithms.</p>
            </div>
            <div class="theory-item">
                <h3>Least Frequently Used (LFU)</h3>
                <p>Replaces the page that has been accessed the least number of times. It keeps track of the access frequency of each page.</p>
            </div>
            <div class="theory-item">
                <h3>Random</h3>
                <p>Randomly selects a page to evict when a new page needs to be loaded. This method is straightforward but does not consider usage patterns.</p>
            </div>
        </div>
    </section>

    <a href="f_theory.html" class="button">Back</a>

    <script src="f_javascript.js"></script>
</body>

</html>